# Тестовое задание — Frontend Developer (React, TypeScript, React Flow)

## Описание

В рамках этого тестового задания вам предоставлен проект, позволяющий строить граф из нод.
Каждая нода инициализируется случайным словарём значений. При соединении двух нод данные из исходной ноды добавляются в целевую.
На экране также отображается текущий FPS (кадры в секунду).

## Основная задача

При количестве нод 3+ во время перетаскивания ноды по рабочей области наблюдается сильное проседание FPS.
Ваша задача — выявить источник проблемы и устранить её.

> После выполнения укажите краткое описание найденной причины и каким способом вы ее устранили.

## Дополнительная задача

Реализовать **сохранение состояния графа** при перезагрузке/закрытии страницы.
Данные графа (нод, связей, словарей) должны восстанавливаться автоматически при открытии страницы.

## Будет плюсом

* Деплой готового решения (например, с помощью [GitHub Pages](https://pages.github.com/)).
* Краткий и понятный код.
* Использование современных подходов React/TypeScript.

## Стек проекта

* Vite
* TypeScript
* React
* React Flow

Удачи!


## Ответ

деплой результата [itHub Pages](https://alexandrmihailovich.github.io/test_task_0406/)

1. Все изменения страляся отправлять отдельными комитами.
2. Сперва обнаружил что useCallback сути не сильно то и работаются, так как в зависимости передаются функции котороые пересоздаются на каждом рендере - исправление заметных результатов не дало.
3. Обернул компоненты нод и таблицы в memo - существенного результата не было.
4. Заметил, что объект с кастомными нодами создаётся в передаче пропс в ReactFlow - исправил. Результат результат явно стал на лицо. фпс при 100 нод перестал опускаться ниже 50
5. решил убрать неудобный и не очень то эффективный useCallback заменив его на кастомных хук с рефой. Но это уже не дало существенных результатов при 150+ нодах.
6. добавил сохранение в LS через redux-persist - этого было достаточно для реализации тз.
7. просмотрел результаты в профилеровщике - едвали получится улучшить результат не используя onlyRenderVisibleElements.
8. добавил onlyRenderVisibleElements - в теории должно хоть тысячи показывать нормально, то только при условие что не все они во вьюпорте